# -*- encoding: utf-8 -*-

"""
第17章 Python作用域(变量定义及查找的地方) && 参数传递(作为输入对象传递给函数的方式)

一：作用域
    1.变量名
        当你在程序中使用一个变量名的时候，Python创建、改变或查找变量名都是在所谓的命名空间中进行的
        当我们讨论搜索变量名对应的代码值的时候，作用域这个术语指的就是命名空间

    2.Python中变量名在第一次赋值时创建并且此时也生成了该变量的作用域
        变量名被赋值的地点关联绑定了一个特定的命名空间，Python中变量名首次赋值的地方决定了变量名的命名空间(能够被搜索到的范围)
    
    3.函数除了具有打包代码的功能之外还为Python增加了一个额外的命名空间层
        一个函数(函数头、函数体)的所有变量名都是与函数的命名空间相关联的
        这意味着：
            def之中的变量名与def之外的变量名不冲突，即使变量名相同
            def之内的变量能够被def之内的代码使用，不能在函数外部使用

    4.语义作用域
      变量的作用域由变量名在代码中的赋值位置决定，变量可以在3个不同的地方分配
        def之内创建的变量是本地变量
        def之外创建的变量是全局变量
        嵌套def之内创建的变量，对嵌套的函数来说是非本地的

二：作用域法则
    1.没有编写函数之前所有的变量都是存在于模块本身或者预先内置好的。
        函数提供了嵌套的命名空间，可以使其内部使用的变量本地化，避免函数内外的变量名冲突
        函数定义了本地作用域；模块定义了全局作用域
            1.内嵌的模块是全局作用域，每个模块都是一个全局作用域，
              对于模块内部来说全局变量就是一个普通变量，对于导入它的模块来说它的全局变量就是这个模块队形的属性
            2.所谓的全局作用域的作用范围仅限于单个文件
              全局是指在一个文件的顶层的变量名，它仅仅对于这个文件内部的代码而言是全局的。
            3.每次对于调用函数都会创建一个新的本地作用域，将会存在一个用那个函数创建出来的命名空间层
            4.函数或函数嵌套中的变量赋值，除非声明为全局变量或非本地变量，否则全为本地变量
                在要在函数内部对一个顶层的全局变量赋值，需要将此变量声明为global
                在局部如果不创建同名全局变量，并且不修改全局变量，则可以正常使用全局变量
                如果要在嵌套的def中使用外层的本地变量就需要使用nolocal语句来声明

三：变量名解析：LEGB原则
    对于一个def语句：
        1.变量名引用时查找变量的顺序：本地(L)、函数内(上一层def/lambda E)、全局(G)、内置(B)
        2.默认变量的赋值会创建一个本地变量
        3.全局声明和非本地的声明将赋值的变量名映射到模块文件内部的作用域        

四：global语句
    1.命名空间的声明
    2.全局变量是位于模块文件内部的顶层的变量名
    3.全局变量如果在函数内部被赋值的话，必须经过声明
    4.全局变量如果在函数内部仅仅被引用而不改变的时候可以不经过声明直接引用
    5.def内部赋值的变量名默认为本地变量，如果将其改为全局变量会引发一些软件工程问题：
        由于变量的值取决于函数调用的顺序，而函数自身是任意顺序进行排列的，导致了程序调试起来变得很困难

五：最小化文件之间的修改
    1.导入其他模块时，导入者自动得到了这个被导入的模块文件的所有变量的访问权
      所以在一个文件被导入后，它的全局作用域实际上就构成了一个模块对象的属性
    2.为全局变量的修改提供访问器和更改器方法，避免直接修改全局变量

六：其他访问全局变量的方法
    1.文件的全局变量在被导入的时候会构成模块对象的属性。因此我们可以使用导入嵌入的模块并对其属性进行赋值来仿造出一个global语句

七：嵌套函数
    1.嵌套作用域(LEGB中的E：包括了任意嵌套函数内部的本地作用域)
        查找规则：本地作用域、由内而外的嵌套函数的本地作用域、全局作用域、内置作用域
        如果变量声明为global，则是创建或修改全局作用域
        如果变量声明外nonlocal，则是创建或修改最近的嵌套函数的本地作用域
    2.工厂函数(闭合)：尽管那个作用域或许不存在但是能够记住嵌套作用于的变量值的函数

八：lambda表达式，会生成后面调用的一个新函数

nonlocal语句：
    使用nonlocal声明的变量必须保证嵌套它的函数中定义过此变量，依然遵循LEGB；
    使用global声明的变量不必保证顶层全局变量中定义过此变量，依然遵循LEGB，但是会直接从顶层作用域中查找
    加快引用，直接在上层嵌套的函数中查找变量，而不会在自己的本地作用域中查找

"""

# Global scope
X = 99

def func(Y):
    # Local scope
    Z = X + Y
    return Z

print(X)
print(func(1))


# Global
X = 88
def func1():
    global  X
    X = 99
    return X

print(X)
func1()
print(X)

x = 'xxx'
y, z = 1, 2
def all_global():
    global x
    x = y + z
    print(x)
print(x)
all_global()
print(x)

# 嵌套函数及作用域
# nonlocal

X = 99
def f1():
    X = 88
    def f2():
        print(X)
    f2()

f1()

# 被嵌套函数作为一个临时的函数, 它会记住嵌套函数中自己用到的变量等
def f3():
    x = 88
    def f4():
        print(x)
    return f4
result = f3()
result()

# 工厂函数
def maker(N):
    def action(X):
        return X ** N
    return action
mAction = maker(2)
print(mAction(2))
print(mAction(3))

mAction2 = maker(3)
print(mAction2(2))
print(mAction2(3))


# 使用lambda表达式代替嵌套层的函数
print("============")
#def func1():
#    x = 4
#    def func2(n):
#        return x ** n
#    return func2

func2 = func1()
print(func2(1))
print(func2(2))

print("===lambda==")
def func3():
    x = 4
    func4 = (lambda n: x ** n)
    return func4
func4 = func3()
print(func4(1))
print(func4(2))

# nonlocal应用
def tester(start):
    state = start
    def nested(label):
        # nonlocal state    # 默认情况下可以根据LEGB访问变量，但是不能够更改，需要声明为nonlocal变量
        # state += 1
        print(label, state)

    return nested

F1 = tester(0)
F1('spam')
